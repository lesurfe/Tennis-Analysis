# -*- coding: utf-8 -*-
"""Tenis image analysis (players, ball, pose) based on Roboflow API.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e7yCU4dxtP9YBIh1V-pHV7IfCKtTq-s8

Before starting make sure that images have been saved on sample_data folder

# **Install libraries**
"""

pip install inference-sdk

pip install Pillow

"""# **Initialize libraries**"""

from inference_sdk import InferenceHTTPClient

from pathlib import Path
import json

from PIL import Image as PIL_Image, ImageDraw
from PIL import ImageDraw, ImageFont # Import ImageFont for text

from IPython.display import Image

import datetime as dt

"""# **Generic functions**"""

starting_time = dt.datetime.now()

"""# **Generate player and ball identification specific functions**"""

def generate_json_for_player_ball_identification (result, output_filename):

  data = result

  if not data:
      print("Error: Dictionary is empty or evaluates to false.")
      exit()

  inference_id = data.get('inference_id') # Get the top-level inference ID, which is the same for all predictions

  formatted_results = [] # Initialize a list to hold the formatted detection results

  if 'predictions' in data: # Extract and format the required variables for each prediction
      for prediction in data['predictions']:

          x_cen = prediction.get('x') # Original coordinates are center (x, y) and (width, height).
          y_cen = prediction.get('y')
          width = prediction.get('width')
          height = prediction.get('height')
          class_id = prediction.get('class')

          if all(v is not None for v in [x_cen, y_cen, width, height]):
              xmin = x_cen - (width / 2) # Calculate bounding box coordinates (xmin, xmax, ymin, ymax) assuming (x, y) is the center of the bounding box
              ymin = y_cen - (height / 2)
              xmax = x_cen + (width / 2)
              ymax = y_cen + (height / 2)

              formatted_results.append({
                  'inference_id': inference_id,
                  'xmin': round(xmin, 2),
                  'ymin': round(ymin, 2),
                  'xmax': round(xmax, 2),
                  'ymax': round(ymax, 2),
                  'class': class_id
              }) # Create a dictionary for the current prediction and add it to the list

  output_data = {'detections': formatted_results} # Wrap the list of results in a top-level key for good practice

  try:
      with open(output_filename, 'w') as f:
          json.dump(output_data, f, indent=4)
      print(f"Successfully wrote detection data (inference_id, bounding boxes, class_id) to {output_filename}")

  except IOError as e:
      print(f"An error occurred while writing the file: {e}")

def draw_boxes_player_ball(image_path, json_path, output_path):
    """
    Loads detection data from a JSON file and draws bounding boxes on the image.
    """

    PLAYER_BOX_COLOR = "chartreuse"
    BALL_BOX_COLOR = "yellow"
    BOX_WIDTH = 3 # Thickness of the bounding box line

    try:
        img = PIL_Image.open(image_path).convert("RGB") # Load the image
        draw = ImageDraw.Draw(img)
        print(f"Loaded image: {image_path} (Size: {img.size[0]}x{img.size[1]})")

    except FileNotFoundError:
        print(f"Error: Image file not found at {image_path}. Please check the path.\n")
        return
    except Exception as e:
        print(f"Error loading image: {e}\n")
        return

    try:
        with open(json_path, 'r') as f:
            data = json.load(f) # Load the detection data from JSON

        detections = data.get('detections', [])
        if not detections:
            print("Warning: JSON file loaded, but 'detections' list is empty. No boxes to draw.")
            img.save(output_path)
            print(f"Saved original image to {output_path} as no boxes were drawn.\n")
            return

    except FileNotFoundError:
        print(f"Error: JSON file not found at {json_path}. Please check the path.\n")
        return

    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON file at {json_path}. Check file contents.\n")
        return

    boxes_drawn = 0 # Draw the bounding boxes

    for detection in detections:
        try:
            xmin = int(detection['xmin']) # Extract coordinates (assuming they are absolute pixel values: xmin, ymin, xmax, ymax)
            ymin = int(detection['ymin'])
            xmax = int(detection['xmax'])
            ymax = int(detection['ymax'])

            box_coords = [(xmin, ymin), (xmax, ymax)] # The box coordinates for PIL's rectangle function

            if detection['class'] == 'player':
              draw.rectangle(box_coords, outline=PLAYER_BOX_COLOR, width=BOX_WIDTH) # Draw the box

            elif detection['class'] == 'ball':
              draw.rectangle(box_coords, outline=BALL_BOX_COLOR, width=BOX_WIDTH) # Draw the box

            boxes_drawn += 1

        except (KeyError, TypeError, ValueError) as e:
            print(f"Skipping malformed detection entry: {detection}. Error: {e}")

    img.save(output_path) # Save the resulting image
    print(f"Successfully drew {boxes_drawn} bounding boxes and saved the result to {output_path}\n")

def player_ball (image_path, json_filename, output_filename, model_id):

  result = CLIENT.infer(image_path, model_id = model_id)
  generate_json_for_player_ball_identification(result, json_filename)
  draw_boxes_player_ball(image_path, json_filename, output_filename)

  return

"""# **Generate pose and keypoint identification specific functions**"""

def generate_json_for_shot_pose_estimation (result, json_filename):

  data = result

  if not data:
      print("Error: Dictionary is empty or evaluates to false.")
      exit()

  inference_id = data.get('inference_id') # Get the top-level inference ID, which is the same for all predictions

  formatted_results = [] # Initialize a list to hold the formatted detection results

  if 'predictions' in data: # Extract and format the required variables for each prediction
      for prediction in data['predictions']:

          x_cen = prediction.get('x') # Original coordinates are center (x, y) and (width, height).
          y_cen = prediction.get('y')
          width = prediction.get('width')
          height = prediction.get('height')
          class_id = prediction.get('class')

          x_nose = prediction.get('keypoints')[0].get('x')
          y_nose = prediction.get('keypoints')[0].get('y')
          nose_id = prediction.get('keypoints')[0].get('class_id')

          x_left_eye = prediction.get('keypoints')[1].get('x')
          y_left_eye = prediction.get('keypoints')[1].get('y')
          left_eye_id = prediction.get('keypoints')[1].get('class_id')

          x_right_eye = prediction.get('keypoints')[2].get('x')
          y_right_eye = prediction.get('keypoints')[2].get('y')
          right_eye_id = prediction.get('keypoints')[2].get('class_id')

          x_left_ear = prediction.get('keypoints')[3].get('x')
          y_left_ear = prediction.get('keypoints')[3].get('y')
          left_ear_id = prediction.get('keypoints')[3].get('class_id')

          x_right_ear = prediction.get('keypoints')[4].get('x')
          y_right_ear = prediction.get('keypoints')[4].get('y')
          right_ear_id = prediction.get('keypoints')[4].get('class_id')

          x_left_shoulder = prediction.get('keypoints')[5].get('x')
          y_left_shoulder = prediction.get('keypoints')[5].get('y')
          left_shoulder_id = prediction.get('keypoints')[5].get('class_id')

          x_right_shoulder = prediction.get('keypoints')[6].get('x')
          y_right_shoulder = prediction.get('keypoints')[6].get('y')
          right_shoulder_id = prediction.get('keypoints')[6].get('class_id')

          x_left_elbow = prediction.get('keypoints')[7].get('x')
          y_left_elbow = prediction.get('keypoints')[7].get('y')
          left_elbow_id = prediction.get('keypoints')[7].get('class_id')

          x_right_elbow = prediction.get('keypoints')[8].get('x')
          y_right_elbow = prediction.get('keypoints')[8].get('y')
          right_elbow_id = prediction.get('keypoints')[8].get('class_id')

          x_left_wrist = prediction.get('keypoints')[9].get('x')
          y_left_wrist = prediction.get('keypoints')[9].get('y')
          left_wrist_id = prediction.get('keypoints')[9].get('class_id')

          x_right_wrist = prediction.get('keypoints')[10].get('x')
          y_right_wrist = prediction.get('keypoints')[10].get('y')
          right_wrist_id = prediction.get('keypoints')[10].get('class_id')
          x_left_hip = prediction.get('keypoints')[11].get('x')
          y_left_hip = prediction.get('keypoints')[11].get('y')
          left_hip_id = prediction.get('keypoints')[11].get('class_id')

          x_right_hip = prediction.get('keypoints')[12].get('x')
          y_right_hip = prediction.get('keypoints')[12].get('y')
          right_hip_id = prediction.get('keypoints')[12].get('class_id')

          x_left_knee = prediction.get('keypoints')[13].get('x')
          y_left_knee = prediction.get('keypoints')[13].get('y')
          left_knee_id = prediction.get('keypoints')[13].get('class_id')

          x_right_knee = prediction.get('keypoints')[14].get('x')
          y_right_knee = prediction.get('keypoints')[14].get('y')
          right_knee_id = prediction.get('keypoints')[14].get('class_id')

          x_left_ankle = prediction.get('keypoints')[15].get('x')
          y_left_ankle = prediction.get('keypoints')[15].get('y')
          left_ankle_id = prediction.get('keypoints')[15].get('class_id')

          x_right_ankle = prediction.get('keypoints')[16].get('x')
          y_right_ankle = prediction.get('keypoints')[16].get('y')
          right_ankle_id = prediction.get('keypoints')[16].get('class_id')

          x_neck = prediction.get('keypoints')[17].get('x')
          y_neck = prediction.get('keypoints')[17].get('y')
          neck_id = prediction.get('keypoints')[17].get('class_id')

          v = [x_cen, y_cen, width, height]
          w = [x_nose, y_nose, nose_id, x_left_eye, y_left_eye, left_eye_id, x_right_eye, y_right_eye, right_eye_id,
              x_left_ear, y_left_ear, left_ear_id, x_right_ear, y_right_ear, right_ear_id,
              x_left_shoulder, y_left_shoulder, left_shoulder_id, x_right_shoulder, y_right_shoulder, right_shoulder_id,
              x_left_elbow, y_left_elbow, left_elbow_id, x_right_elbow, y_right_elbow, right_elbow_id,
              x_left_wrist, y_left_wrist, left_wrist_id, x_right_wrist, y_right_wrist, right_wrist_id,
              x_left_hip, y_left_hip, left_hip_id, x_right_hip, y_right_hip, right_hip_id,
              x_left_knee, y_left_knee, left_knee_id, x_right_knee, y_right_knee, right_knee_id,
              x_left_ankle, y_left_ankle, left_ankle_id, x_right_ankle, y_right_ankle, right_ankle_id,
              x_neck, y_neck, neck_id]


          if all(item is not None for item in v) and all(item is not None for item in w):
              xmin = x_cen - (width / 2) # Calculate bounding box coordinates (xmin, xmax, ymin, ymax) assuming (x, y) is the center of the bounding box
              ymin = y_cen - (height / 2)
              xmax = x_cen + (width / 2)
              ymax = y_cen + (height / 2)

              formatted_results.append({
                  'inference_id': inference_id,
                  'xmin': round(xmin, 2),
                  'ymin': round(ymin, 2),
                  'xmax': round(xmax, 2),
                  'ymax': round(ymax, 2),
                  'class': class_id,
                  'x_nose': x_nose,
                  'y_nose': y_nose,
                  'nose': nose_id,
                  'x_left_eye': x_left_eye,
                  'y_left_eye': y_left_eye,
                  'left_eye': left_eye_id,
                  'x_right_eye': x_right_eye,
                  'y_right_eye': y_right_eye,
                  'right_eye': right_eye_id,
                  'x_left_ear': x_left_ear,
                  'y_left_ear': y_left_ear,
                  'left_ear': left_ear_id,
                  'x_right_ear': x_right_ear,
                  'y_right_ear': y_right_ear,
                  'right_ear': right_ear_id,
                  'x_left_shoulder': x_left_shoulder,
                  'y_left_shoulder': y_left_shoulder,
                  'left_shoulder': left_shoulder_id,
                  'x_right_shoulder': x_right_shoulder,
                  'y_right_shoulder': y_right_shoulder,
                  'right_shoulder': right_shoulder_id,
                  'x_left_elbow': x_left_elbow,
                  'y_left_elbow': y_left_elbow,
                  'left_elbow': left_elbow_id,
                  'x_right_elbow': x_right_elbow,
                  'y_right_elbow': y_right_elbow,
                  'right_elbow': right_elbow_id,
                  'x_left_wrist': x_left_wrist,
                  'y_left_wrist': y_left_wrist,
                  'left_wrist': left_wrist_id,
                  'x_left_hip': x_left_hip,
                  'y_left_hip': y_left_hip,
                  'left_hip': left_hip_id,
                  'x_right_hip': x_right_hip,
                  'y_right_hip': y_right_hip,
                  'right_hip': right_hip_id,
                  'x_left_knee': x_left_knee,
                  'y_left_knee': y_left_knee,
                  'left_knee': left_knee_id,
                  'x_right_knee': x_right_knee,
                  'y_right_knee': y_right_knee,
                  'right_knee': right_knee_id,
                  'x_left_ankle': x_left_ankle,
                  'y_left_ankle': y_left_ankle,
                  'left_ankle': left_ankle_id,
                  'x_right_ankle': x_right_ankle,
                  'y_right_ankle': y_right_ankle,
                  'right_ankle': right_ankle_id,
                  'x_neck': x_neck,
                  'y_neck': y_neck,
                  'neck': neck_id
              }) # Create a dictionary for the current prediction and add it to the list

          elif all(item is not None for item in v):
              xmin = x_cen - (width / 2) # Calculate bounding box coordinates (xmin, xmax, ymin, ymax) assuming (x, y) is the center of the bounding box
              ymin = y_cen - (height / 2)
              xmax = x_cen + (width / 2)
              ymax = y_cen + (height / 2)

              formatted_results.append({
                  'inference_id': inference_id,
                  'xmin': round(xmin, 2),
                  'ymin': round(ymin, 2),
                  'xmax': round(xmax, 2),
                  'ymax': round(ymax, 2),
                  'class': class_id
              })

          elif all(item is not None for item in w):
              formatted_results.append({
                  'inference_id': inference_id,
                  'x_nose': x_nose,
                  'y_nose': y_nose,
                  'nose': nose_id,
                  'x_left_eye': x_left_eye,
                  'y_left_eye': y_left_eye,
                  'left_eye': left_eye_id,
                  'x_right_eye': x_right_eye,
                  'y_right_eye': y_right_eye,
                  'right_eye': right_eye_id,
                  'x_left_ear': x_left_ear,
                  'y_left_ear': y_left_ear,
                  'left_ear': left_ear_id,
                  'x_right_ear': x_right_ear,
                  'y_right_ear': y_right_ear,
                  'right_ear': right_ear_id,
                  'x_left_shoulder': x_left_shoulder,
                  'y_left_shoulder': y_left_shoulder,
                  'left_shoulder': left_shoulder_id,
                  'x_right_shoulder': x_right_shoulder,
                  'y_right_shoulder': y_right_shoulder,
                  'right_shoulder': right_shoulder_id,
                  'x_left_elbow': x_left_elbow,
                  'y_left_elbow': y_left_elbow,
                  'left_elbow': left_elbow_id,
                  'x_right_elbow': x_right_elbow,
                  'y_right_elbow': y_right_elbow,
                  'right_elbow': right_elbow_id,
                  'x_left_wrist': x_left_wrist,
                  'y_left_wrist': y_left_wrist,
                  'left_wrist': left_wrist_id,
                  'x_left_hip': x_left_hip,
                  'y_left_hip': y_left_hip,
                  'left_hip': left_hip_id,
                  'x_right_hip': x_right_hip,
                  'y_right_hip': y_right_hip,
                  'right_hip': right_hip_id,
                  'x_left_knee': x_left_knee,
                  'y_left_knee': y_left_knee,
                  'left_knee': left_knee_id,
                  'x_right_knee': x_right_knee,
                  'y_right_knee': y_right_knee,
                  'right_knee': right_knee_id,
                  'x_left_ankle': x_left_ankle,
                  'y_left_ankle': y_left_ankle,
                  'left_ankle': left_ankle_id,
                  'x_right_ankle': x_right_ankle,
                  'y_right_ankle': y_right_ankle,
                  'right_ankle': right_ankle_id,
                  'x_neck': x_neck,
                  'y_neck': y_neck,
                  'neck': neck_id
              })

  output_data = {'detections': formatted_results} # Wrap the list of results in a top-level key for good practice

  try:
      with open(json_filename, 'w') as f:
          json.dump(output_data, f, indent=4)
      print(f"Successfully wrote detection data (inference_id, bounding boxes, class_id, keypoints, keypoint classes) to {json_filename}")

  except IOError as e:
      print(f"An error occurred while writing the file: {e}")

def draw_boxes_shot(image_path, json_path, output_path):

    BOX_COLOR = "white"
    BOX_WIDTH = 6 # Thickness of the bounding box line
    TEXT_COLOR = "white"
    TEXT_SIZE = 200

    try:
        font = ImageFont.truetype("arial.ttf", TEXT_SIZE)

    except IOError:
        print("Warning: Arial font not found. Using default PIL font.")
        font = ImageFont.load_default()

    try:
        img = PIL_Image.open(image_path).convert("RGB") # Load the image
        draw = ImageDraw.Draw(img)
        print(f"Loaded image: {image_path} (Size: {img.size[0]}x{img.size[1]})")

    except FileNotFoundError:
        print(f"Error: Image file not found at {image_path}. Please check the path.\n")
        return

    except Exception as e:
        print(f"Error loading image: {e}\n")
        return

    try:
        with open(json_path, 'r') as f:
            data = json.load(f) # Load the detection data from JSON

        detections = data.get('detections', [])

        if not detections:
            print("Warning: JSON file loaded, but 'detections' list is empty. No boxes to draw.")
            img.save(output_path)
            print(f"Saved original image to {output_path} as no boxes were drawn.\n")
            return

    except FileNotFoundError:
        print(f"Error: JSON file not found at {json_path}. Please check the path.\n")
        return

    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON file at {json_path}. Check file contents.\n")
        return

    boxes_drawn = 0 # Draw the bounding boxes

    for detection in detections:
        try:
            xmin = int(detection['xmin']) # Extract coordinates (assuming they are absolute pixel values: xmin, ymin, xmax, ymax)
            ymin = int(detection['ymin'])
            xmax = int(detection['xmax'])
            ymax = int(detection['ymax'])

            class_label = detection['class'] # Get the text stored in the 'class' variable

            box_coords = [(xmin, ymin), (xmax, ymax)] # The box coordinates for PIL's rectangle function

            draw.rectangle(box_coords, outline=BOX_COLOR, width=BOX_WIDTH) # Draw the box

            text_x = xmin + BOX_WIDTH
            text_y = ymin + BOX_WIDTH

            draw.text((text_x, text_y), class_label, fill=TEXT_COLOR, font=font) # Draw the text label

            boxes_drawn += 1


        except (KeyError, TypeError, ValueError) as e:
            print(f"Skipping malformed detection entry: {prediction}. Error: {e}")


    img.save(output_path) # Save the resulting image
    print(f"Successfully drew {boxes_drawn} bounding boxes and saved the result to {output_path}\n")

def draw_keypoints_pose(image_path, json_path, output_path):

    """
    Loads keypoint coordinates from a JSON file and draws them as points
    on the corresponding image.
    """

    point_radius=10
    point_color="white"

    try:
        img = PIL_Image.open(image_path).convert("RGB")
        draw = ImageDraw.Draw(img)
        print(f"Loaded image: {image_path} (Size: {img.size[0]}x{img.size[1]})")

    except FileNotFoundError:
        print(f"Error: Image file not found at {image_path}. Please check the path.\n")
        return
    except Exception as e:
        print(f"Error loading image: {e}\n")
        return

    try:
        with open(json_path, 'r') as f:
            data = json.load(f)

        detections = data.get('detections', []) # We expect a list of detections under the 'detections' key

        if not detections:
            print("Warning: JSON file loaded, but 'detections' list is empty. No keypoints to draw.")
            img.save(output_path)
            print(f"Saved original image to {output_path}.\n")
            return

    except FileNotFoundError:
        print(f"Error: JSON file not found at {json_path}. Please check the path.\n")
        return
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON file at {json_path}. Check file contents.\n")
        return

    points_drawn = 0

    for detection in detections:
        keypoint_keys = [k for k in detection.keys() if k.startswith('x_')] # We look for keys starting with 'x_' to find coordinates

        for x_key in keypoint_keys:
            y_key = x_key.replace('x_', 'y_') # Determine the corresponding y-key and class name
            class_name = x_key.replace('x_', '')

            x = detection.get(x_key) # Extract coordinates
            y = detection.get(y_key)

            if x is not None and y is not None:
                try:
                    x_int = int(x) # Convert coordinates to integers
                    y_int = int(y)

                    point_coords = [
                        x_int - point_radius,
                        y_int - point_radius,
                        x_int + point_radius,
                        y_int + point_radius
                    ] # Define bounding box for the point (a small circle/square)

                    draw.ellipse(point_coords, fill=point_color) # Draw a circle/ellipse for the keypoint
                    points_drawn += 1


                except (TypeError, ValueError):
                    print(f"Skipping malformed coordinate for {class_name}: x={x}, y={y}")
                    continue

    img.save(output_path)
    print(f"Successfully drew {points_drawn} keypoints and saved the result to {output_path}\n")

def shot_pose (image_path, json_filename, bb_output_filename, kp_output_filename, model_id):

  result = CLIENT.infer(image_path, model_id = model_id)
  generate_json_for_shot_pose_estimation(result, json_filename)
  draw_boxes_shot(image_path, json_filename, bb_output_filename)
  draw_keypoints_pose(image_path, json_filename, kp_output_filename)
  return

"""# **Generate court keypoints identification specific functions**"""

def generate_json_for_court_keypoints (result, json_filename):

  data = result

  if not data:
      print("Error: Dictionary is empty or evaluates to false.")
      exit()

  inference_id = data.get('inference_id') # Get the top-level inference ID, which is the same for all predictions

  formatted_results = [] # Initialize a list to hold the formatted detection results

  if 'predictions' in data: # Extract and format the required variables for each prediction
      for prediction in data['predictions']:
          # The keypoints are inside the 'keypoints' list within the current prediction dictionary
          keypoints_list = prediction.get('keypoints', [])

          for keypoint in keypoints_list:
              x = keypoint.get('x')
              y = keypoint.get('y')
              class_id = keypoint.get('class_id')
              class_name = keypoint.get('class') # Using 'class' from keypoint for consistency with other functions

              formatted_results.append({
                  'inference_id': inference_id, # Use the top-level inference_id for all keypoints from this inference
                  'x': x,
                  'y': y,
                  'class': class_name # Use the class name of the keypoint
              })

  output_data = {'detections': formatted_results} # Wrap the list of results in a top-level key for good practice

  try:
      with open(json_filename, 'w') as f:
          json.dump(output_data, f, indent=4)
      print(f"Successfully wrote detection data (inference_id, keypoints, class) to {json_filename}")

  except IOError as e:
      print(f"An error occurred while writing the file: {e}")

def draw_court_keypoints(image_path, json_path, output_path):
    """
    Loads keypoint coordinates from a JSON file and draws them as points
    on the corresponding image.
    """

    point_radius=10
    point_color="deeppink"

    try:
        img = PIL_Image.open(image_path).convert("RGB")
        draw = ImageDraw.Draw(img)
        print(f"Loaded image: {image_path} (Size: {img.size[0]}x{img.size[1]})")

    except FileNotFoundError:
        print(f"Error: Image file not found at {image_path}. Please check the path.\n")
        return
    except Exception as e:
        print(f"Error loading image: {e}\n")
        return

    try:
        with open(json_path, 'r') as f:
            data = json.load(f)

        detections = data.get('detections', []) # We expect a list of detections under the 'detections' key

        if not detections:
            print("Warning: JSON file loaded, but 'detections' list is empty. No keypoints to draw.")
            img.save(output_path)
            print(f"Saved original image to {output_path}.\n")
            return

    except FileNotFoundError:
        print(f"Error: JSON file not found at {json_path}. Please check the path.\n")
        return
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON file at {json_path}. Check file contents.\n")
        return

    points_drawn = 0

    for detection in detections:

        x = detection.get('x')
        y = detection.get('y')

        if x is not None and y is not None:
            try:
              x_int = int(x)
              y_int = int(y)
              point_coords = [
                  x_int - point_radius,
                  y_int - point_radius,
                  x_int + point_radius,
                  y_int + point_radius
              ]
              draw.ellipse(point_coords, fill=point_color) # Draw a circle/ellipse for the keypoint
              points_drawn += 1

            except (TypeError, ValueError):
              print(f"Skipping malformed coordinate: x={x}, y={y}")
              continue

    img.save(output_path)
    print(f"Successfully drew {points_drawn} keypoints and saved the result to {output_path}\n")

def court_keypoints (image_path, json_filename, output_filename, model_id):

  result = CLIENT.infer(image_path, model_id = model_id)
  print(result)
  generate_json_for_court_keypoints(result, json_filename)
  draw_court_keypoints(image_path, json_filename, output_filename)
  return

"""# **Roboflow API's**"""

CLIENT = InferenceHTTPClient(api_url="https://serverless.roboflow.com",api_key="6LIHJqhEOwzsiZdxnyOU")

"""# **Player and Ball Identification**

Model: https://universe.roboflow.com/abiya-thesis/tennis-player-and-tennis-ball-ei0vm/model/5
"""

# player_ball (image_path, json_filename, output_filename, model_id)

player_ball ("/content/tennis1.png", "tennis1_player_ball.json", "/content/tennis1_player_ball_bb.png", "tennis-player-and-tennis-ball-ei0vm/5")
player_ball ("/content/tennis2.png", "tennis2_player_ball.json", "/content/tennis2_player_ball_bb.png", "tennis-player-and-tennis-ball-ei0vm/5")

Image("/content/tennis1_player_ball_bb.png")

"""# **Shot Type and Pose Identification**

Model: https://universe.roboflow.com/firas-tlili-twfri/tennis-action-recognition-xhxbc/model/1
"""

# shot_pose (image_path, json_filename, shot_output_filename, pose_output_filename, model_id)

shot_pose ("/content/tennis1.png", "tennis1_shot_pose.json", "/content/tennis1_shot_bb.png", "/content/tennis1_pose_kp.png", "tennis-action-recognition-xhxbc/1")
shot_pose ("/content/tennis2.png", "tennis2_shot_pose.json", "/content/tennis2_shot_bb.png", "/content/tennis2_pose_kp.png", "tennis-action-recognition-xhxbc/1")

Image("/content/tennis1_shot_bb.png")

Image("/content/tennis1_pose_kp.png")

"""# **Court Keypoints Identification**

Model: https://universe.roboflow.com/desertsloth1/tennis-court-detection-onesd/model/10
"""

# court_keypoints (image_path, json_filename, output_filename, model_id)

court_keypoints("/content/tennis1.png", "tennis1_court_kp.json", "/content/tennis1_court_kp.png", "tennis-court-detection-onesd/10")
court_keypoints("/content/tennis2.png", "tennis2_court_kp.json", "/content/tennis2_court_kp.png", "tennis-court-detection-onesd/10")

Image("/content/tennis1_court_kp.png")

Image("/content/tennis2_court_kp.png")

"""# **Single Image showing player, ball, shot identification, pose and court keypoints**"""

def draw_all (image_path, player_ball_json, shot_pose_json, court_kp_json, output_path):
  draw_boxes_player_ball(image_path, player_ball_json, output_path)
  draw_boxes_shot(output_path, shot_pose_json, output_path)
  draw_keypoints_pose(output_path, shot_pose_json, output_path)
  draw_court_keypoints(output_path, court_kp_json, output_path)

# draw_all (image_path, player_ball_json, shot_pose_json, court_kp_json, output_path)

draw_all ("/content/tennis1.png", "/content/tennis1_player_ball.json", "/content/tennis1_shot_pose.json", "/content/tennis1_court_kp.json", "/content/tennis1_all.png")
draw_all ("/content/tennis2.png", "/content/tennis2_player_ball.json", "/content/tennis2_shot_pose.json", "/content/tennis2_court_kp.json", "/content/tennis2_all.png")

Image("/content/tennis1_all.png")

Image("/content/tennis2_all.png")

finishing_time = dt.datetime.now()
total_time = finishing_time - starting_time
print(f"Total time taken: {total_time}")